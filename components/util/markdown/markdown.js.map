{"version":3,"file":"markdown.js","sources":["markdown.js"],"sourcesContent":["// Released under MIT license\r\n// Copyright (c) 2009-2010 Dominic Baggott\r\n// Copyright (c) 2009-2010 Ash Berlin\r\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\r\n\r\n(function (expose) {\r\n\r\n    /**\r\n     *  class Markdown\r\n     *\r\n     *  Markdown processing in Javascript done right. We have very particular views\r\n     *  on what constitutes 'right' which include:\r\n     *\r\n     *  - produces well-formed HTML (this means that em and strong nesting is\r\n     *    important)\r\n     *\r\n     *  - has an intermediate representation to allow processing of parsed data (We\r\n     *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\r\n     *\r\n     *  - is easily extensible to add new dialects without having to rewrite the\r\n     *    entire parsing mechanics\r\n     *\r\n     *  - has a good test suite\r\n     *\r\n     *  This implementation fulfills all of these (except that the test suite could\r\n     *  do with expanding to automatically run all the fixtures from other Markdown\r\n     *  implementations.)\r\n     *\r\n     *  ##### Intermediate Representation\r\n     *\r\n     *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\r\n     *\r\n     *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\r\n     **/\r\n    var Markdown = expose.Markdown = function Markdown(dialect) {\r\n        switch (typeof dialect) {\r\n            case \"undefined\":\r\n                this.dialect = Markdown.dialects.Gruber;\r\n                break;\r\n            case \"object\":\r\n                this.dialect = dialect;\r\n                break;\r\n            default:\r\n                if (dialect in Markdown.dialects) {\r\n                    this.dialect = Markdown.dialects[dialect];\r\n                }\r\n                else {\r\n                    throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\r\n                }\r\n                break;\r\n        }\r\n        this.em_state = [];\r\n        this.strong_state = [];\r\n        this.debug_indent = \"\";\r\n    };\r\n\r\n    /**\r\n     *  parse( markdown, [dialect] ) -> JsonML\r\n     *  - markdown (String): markdown string to parse\r\n     *  - dialect (String | Dialect): the dialect to use, defaults to gruber\r\n     *\r\n     *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\r\n     **/\r\n    expose.parse = function (source, dialect) {\r\n        // dialect will default if undefined\r\n        var md = new Markdown(dialect);\r\n        return md.toTree(source);\r\n    };\r\n\r\n    /**\r\n     *  toHTML( markdown, [dialect]  ) -> String\r\n     *  toHTML( md_tree ) -> String\r\n     *  - markdown (String): markdown string to parse\r\n     *  - md_tree (Markdown.JsonML): parsed markdown tree\r\n     *\r\n     *  Take markdown (either as a string or as a JsonML tree) and run it through\r\n     *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\r\n     **/\r\n    expose.toHTML = function toHTML(source, dialect, options) {\r\n        var input = expose.toHTMLTree(source, dialect, options);\r\n\r\n        return expose.renderJsonML(input);\r\n    };\r\n\r\n    /**\r\n     *  toHTMLTree( markdown, [dialect] ) -> JsonML\r\n     *  toHTMLTree( md_tree ) -> JsonML\r\n     *  - markdown (String): markdown string to parse\r\n     *  - dialect (String | Dialect): the dialect to use, defaults to gruber\r\n     *  - md_tree (Markdown.JsonML): parsed markdown tree\r\n     *\r\n     *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\r\n     *  to this function, it is first parsed into a markdown tree by calling\r\n     *  [[parse]].\r\n     **/\r\n    expose.toHTMLTree = function toHTMLTree(input, dialect, options) {\r\n        // convert string input to an MD tree\r\n        if (typeof input === \"string\") input = this.parse(input, dialect);\r\n\r\n        // Now convert the MD tree to an HTML tree\r\n\r\n        // remove references from the tree\r\n        var attrs = extract_attr(input),\r\n            refs = {};\r\n\r\n        if (attrs && attrs.references) {\r\n            refs = attrs.references;\r\n        }\r\n\r\n        var html = convert_tree_to_html(input, refs, options);\r\n        merge_text_nodes(html);\r\n        return html;\r\n    };\r\n\r\n    // For Spidermonkey based engines\r\n    function mk_block_toSource() {\r\n        return \"Markdown.mk_block( \" +\r\n            uneval(this.toString()) +\r\n            \", \" +\r\n            uneval(this.trailing) +\r\n            \", \" +\r\n            uneval(this.lineNumber) +\r\n            \" )\";\r\n    }\r\n\r\n    // node\r\n    function mk_block_inspect() {\r\n        var util = require('util');\r\n        return \"Markdown.mk_block( \" +\r\n            util.inspect(this.toString()) +\r\n            \", \" +\r\n            util.inspect(this.trailing) +\r\n            \", \" +\r\n            util.inspect(this.lineNumber) +\r\n            \" )\";\r\n\r\n    }\r\n\r\n    var mk_block = Markdown.mk_block = function (block, trail, line) {\r\n        // Be helpful for default case in tests.\r\n        if (arguments.length == 1) trail = \"\\n\\n\";\r\n\r\n        var s = new String(block);\r\n        s.trailing = trail;\r\n        // To make it clear its not just a string\r\n        s.inspect = mk_block_inspect;\r\n        s.toSource = mk_block_toSource;\r\n\r\n        if (line != undefined)\r\n            s.lineNumber = line;\r\n\r\n        return s;\r\n    };\r\n\r\n    function count_lines(str) {\r\n        var n = 0, i = -1;\r\n        while ((i = str.indexOf('\\n', i + 1)) !== -1) n++;\r\n        return n;\r\n    }\r\n\r\n    // Internal - split source into rough blocks\r\n    Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {\r\n        // [\\s\\S] matches _anything_ (newline or space)\r\n        var re = /([\\s\\S]+?)($|\\n(?:\\s*\\n|$)+)/g,\r\n            blocks = [],\r\n            m;\r\n\r\n        var line_no = 1;\r\n\r\n        if ((m = /^(\\s*\\n)/.exec(input)) != null) {\r\n            // skip (but count) leading blank lines\r\n            line_no += count_lines(m[0]);\r\n            re.lastIndex = m[0].length;\r\n        }\r\n\r\n        while ((m = re.exec(input)) !== null) {\r\n            blocks.push(mk_block(m[1], m[2], line_no));\r\n            line_no += count_lines(m[0]);\r\n        }\r\n\r\n        return blocks;\r\n    };\r\n\r\n    /**\r\n     *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\r\n     *  - block (String): the block to process\r\n     *  - next (Array): the following blocks\r\n     *\r\n     * Process `block` and return an array of JsonML nodes representing `block`.\r\n     *\r\n     * It does this by asking each block level function in the dialect to process\r\n     * the block until one can. Succesful handling is indicated by returning an\r\n     * array (with zero or more JsonML nodes), failure by a false value.\r\n     *\r\n     * Blocks handlers are responsible for calling [[Markdown#processInline]]\r\n     * themselves as appropriate.\r\n     *\r\n     * If the blocks were split incorrectly or adjacent blocks need collapsing you\r\n     * can adjust `next` in place using shift/splice etc.\r\n     *\r\n     * If any of this default behaviour is not right for the dialect, you can\r\n     * define a `__call__` method on the dialect that will get invoked to handle\r\n     * the block processing.\r\n     */\r\n    Markdown.prototype.processBlock = function processBlock(block, next) {\r\n        var cbs = this.dialect.block,\r\n            ord = cbs.__order__;\r\n\r\n        if (\"__call__\" in cbs) {\r\n            return cbs.__call__.call(this, block, next);\r\n        }\r\n\r\n        for (var i = 0; i < ord.length; i++) {\r\n            //D:this.debug( \"Testing\", ord[i] );\r\n            var res = cbs[ord[i]].call(this, block, next);\r\n            if (res) {\r\n                //D:this.debug(\"  matched\");\r\n                if (!isArray(res) || (res.length > 0 && !(isArray(res[0]))))\r\n                    this.debug(ord[i], \"didn't return a proper array\");\r\n                //D:this.debug( \"\" );\r\n                return res;\r\n            }\r\n        }\r\n\r\n        // Uhoh! no match! Should we throw an error?\r\n        return [];\r\n    };\r\n\r\n    Markdown.prototype.processInline = function processInline(block) {\r\n        return this.dialect.inline.__call__.call(this, String(block));\r\n    };\r\n\r\n    /**\r\n     *  Markdown#toTree( source ) -> JsonML\r\n     *  - source (String): markdown source to parse\r\n     *\r\n     *  Parse `source` into a JsonML tree representing the markdown document.\r\n     **/\r\n    // custom_tree means set this.tree to `custom_tree` and restore old value on return\r\n    Markdown.prototype.toTree = function toTree(source, custom_root) {\r\n        var blocks = source instanceof Array ? source : this.split_blocks(source);\r\n\r\n        // Make tree a member variable so its easier to mess with in extensions\r\n        var old_tree = this.tree;\r\n        try {\r\n            this.tree = custom_root || this.tree || [\"markdown\"];\r\n\r\n            blocks:\r\n            while (blocks.length) {\r\n                var b = this.processBlock(blocks.shift(), blocks);\r\n\r\n                // Reference blocks and the like won't return any content\r\n                if (!b.length) continue blocks;\r\n\r\n                this.tree.push.apply(this.tree, b);\r\n            }\r\n            return this.tree;\r\n        }\r\n        finally {\r\n            if (custom_root) {\r\n                this.tree = old_tree;\r\n            }\r\n        }\r\n    };\r\n\r\n    // Noop by default\r\n    Markdown.prototype.debug = function () {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        args.unshift(this.debug_indent);\r\n        if (typeof print !== \"undefined\")\r\n            print.apply(print, args);\r\n        if (typeof console !== \"undefined\" && typeof console.log !== \"undefined\")\r\n            console.log.apply(null, args);\r\n    }\r\n\r\n    Markdown.prototype.loop_re_over_block = function (re, block, cb) {\r\n        // Dont use /g regexps with this\r\n        var m,\r\n            b = block.valueOf();\r\n\r\n        while (b.length && (m = re.exec(b)) != null) {\r\n            b = b.substr(m[0].length);\r\n            cb.call(this, m);\r\n        }\r\n        return b;\r\n    };\r\n\r\n    /**\r\n     * Markdown.dialects\r\n     *\r\n     * Namespace of built-in dialects.\r\n     **/\r\n    Markdown.dialects = {};\r\n\r\n    /**\r\n     * Markdown.dialects.Gruber\r\n     *\r\n     * The default dialect that follows the rules set out by John Gruber's\r\n     * markdown.pl as closely as possible. Well actually we follow the behaviour of\r\n     * that script which in some places is not exactly what the syntax web page\r\n     * says.\r\n     **/\r\n    Markdown.dialects.Gruber = {\r\n        block: {\r\n            atxHeader: function atxHeader(block, next) {\r\n                var m = block.match(/^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/);\r\n\r\n                if (!m) return undefined;\r\n\r\n                var header = [\"header\", { level: m[1].length }];\r\n                Array.prototype.push.apply(header, this.processInline(m[2]));\r\n\r\n                if (m[0].length < block.length)\r\n                    next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));\r\n\r\n                return [header];\r\n            },\r\n\r\n            setextHeader: function setextHeader(block, next) {\r\n                var m = block.match(/^(.*)\\n([-=])\\2\\2+(?:\\n|$)/);\r\n\r\n                if (!m) return undefined;\r\n\r\n                var level = (m[2] === \"=\") ? 1 : 2;\r\n                var header = [\"header\", { level: level }, m[1]];\r\n\r\n                if (m[0].length < block.length)\r\n                    next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));\r\n\r\n                return [header];\r\n            },\r\n\r\n            code: function code(block, next) {\r\n                // |    Foo\r\n                // |bar\r\n                // should be a code block followed by a paragraph. Fun\r\n                //\r\n                // There might also be adjacent code block to merge.\r\n\r\n                var ret = [],\r\n                    re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\r\n                    lines;\r\n\r\n                // 4 spaces + content\r\n                if (!block.match(re)) return undefined;\r\n\r\n                block_search:\r\n                do {\r\n                    // Now pull out the rest of the lines\r\n                    var b = this.loop_re_over_block(\r\n                        re, block.valueOf(), function (m) { ret.push(m[1]); });\r\n\r\n                    if (b.length) {\r\n                        // Case alluded to in first comment. push it back on as a new block\r\n                        next.unshift(mk_block(b, block.trailing));\r\n                        break block_search;\r\n                    }\r\n                    else if (next.length) {\r\n                        // Check the next block - it might be code too\r\n                        if (!next[0].match(re)) break block_search;\r\n\r\n                        // Pull how how many blanks lines follow - minus two to account for .join\r\n                        ret.push(block.trailing.replace(/[^\\n]/g, '').substring(2));\r\n\r\n                        block = next.shift();\r\n                    }\r\n                    else {\r\n                        break block_search;\r\n                    }\r\n                } while (true);\r\n\r\n                return [[\"code_block\", ret.join(\"\\n\")]];\r\n            },\r\n\r\n            horizRule: function horizRule(block, next) {\r\n                // this needs to find any hr in the block to handle abutting blocks\r\n                var m = block.match(/^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/);\r\n\r\n                if (!m) {\r\n                    return undefined;\r\n                }\r\n\r\n                var jsonml = [[\"hr\"]];\r\n\r\n                // if there's a leading abutting block, process it\r\n                if (m[1]) {\r\n                    jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));\r\n                }\r\n\r\n                // if there's a trailing abutting block, stick it into next\r\n                if (m[3]) {\r\n                    next.unshift(mk_block(m[3]));\r\n                }\r\n\r\n                return jsonml;\r\n            },\r\n\r\n            // There are two types of lists. Tight and loose. Tight lists have no whitespace\r\n            // between the items (and r in text just in the <li>) and loose lists,\r\n            // which have an empty line between list items, resulting in (one or more)\r\n            // paragraphs inside the <li>.\r\n            //\r\n            // There are all sorts weird edge cases about the original markdown.pl's\r\n            // handling of lists:\r\n            //\r\n            // * Nested lists are supposed to be indented by four chars per level. But\r\n            //   if they aren't, you can get a nested list by indenting by less than\r\n            //   four so long as the indent doesn't match an indent of an existing list\r\n            //   item in the 'nest stack'.\r\n            //\r\n            // * The type of the list (bullet or number) is controlled just by the\r\n            //    first item at the indent. Subsequent changes are ignored unless they\r\n            //    are for nested lists\r\n            //\r\n            lists: (function () {\r\n                // Use a closure to hide a few variables.\r\n                var any_list = \"[*+-]|\\\\d+\\\\.\",\r\n                    bullet_list = /[*+-]/,\r\n                    number_list = /\\d+\\./,\r\n                    // Capture leading indent as it matters for determining nested lists.\r\n                    is_list_re = new RegExp(\"^( {0,3})(\" + any_list + \")[ \\t]+\"),\r\n                    indent_re = \"(?: {0,3}\\\\t| {4})\";\r\n\r\n                // TODO: Cache this regexp for certain depths.\r\n                // Create a regexp suitable for matching an li for a given stack depth\r\n                function regex_for_depth(depth) {\r\n\r\n                    return new RegExp(\r\n                        // m[1] = indent, m[2] = list_type\r\n                        \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\r\n                        // m[3] = cont\r\n                        \"(^\" + indent_re + \"{0,\" + (depth - 1) + \"}[ ]{0,4})\"\r\n                    );\r\n                }\r\n                function expand_tab(input) {\r\n                    return input.replace(/ {0,3}\\t/g, \"    \");\r\n                }\r\n\r\n                // Add inline content `inline` to `li`. inline comes from processInline\r\n                // so is an array of content\r\n                function add(li, loose, inline, nl) {\r\n                    if (loose) {\r\n                        li.push([\"para\"].concat(inline));\r\n                        return;\r\n                    }\r\n                    // Hmmm, should this be any block level element or just paras?\r\n                    var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == \"para\"\r\n                        ? li[li.length - 1]\r\n                        : li;\r\n\r\n                    // If there is already some content in this list, add the new line in\r\n                    if (nl && li.length > 1) inline.unshift(nl);\r\n\r\n                    for (var i = 0; i < inline.length; i++) {\r\n                        var what = inline[i],\r\n                            is_str = typeof what == \"string\";\r\n                        if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == \"string\") {\r\n                            add_to[add_to.length - 1] += what;\r\n                        }\r\n                        else {\r\n                            add_to.push(what);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // contained means have an indent greater than the current one. On\r\n                // *every* line in the block\r\n                function get_contained_blocks(depth, blocks) {\r\n\r\n                    var re = new RegExp(\"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\"),\r\n                        replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\r\n                        ret = [];\r\n\r\n                    while (blocks.length > 0) {\r\n                        if (re.exec(blocks[0])) {\r\n                            var b = blocks.shift(),\r\n                                // Now remove that indent\r\n                                x = b.replace(replace, \"\");\r\n\r\n                            ret.push(mk_block(x, b.trailing, b.lineNumber));\r\n                        }\r\n                        break;\r\n                    }\r\n                    return ret;\r\n                }\r\n\r\n                // passed to stack.forEach to turn list items up the stack into paras\r\n                function paragraphify(s, i, stack) {\r\n                    var list = s.list;\r\n                    var last_li = list[list.length - 1];\r\n\r\n                    if (last_li[1] instanceof Array && last_li[1][0] == \"para\") {\r\n                        return;\r\n                    }\r\n                    if (i + 1 == stack.length) {\r\n                        // Last stack frame\r\n                        // Keep the same array, but replace the contents\r\n                        last_li.push([\"para\"].concat(last_li.splice(1)));\r\n                    }\r\n                    else {\r\n                        var sublist = last_li.pop();\r\n                        last_li.push([\"para\"].concat(last_li.splice(1)), sublist);\r\n                    }\r\n                }\r\n\r\n                // The matcher function\r\n                return function (block, next) {\r\n                    var m = block.match(is_list_re);\r\n                    if (!m) return undefined;\r\n\r\n                    function make_list(m) {\r\n                        var list = bullet_list.exec(m[2])\r\n                            ? [\"bulletlist\"]\r\n                            : [\"numberlist\"];\r\n\r\n                        stack.push({ list: list, indent: m[1] });\r\n                        return list;\r\n                    }\r\n\r\n\r\n                    var stack = [], // Stack of lists for nesting.\r\n                        list = make_list(m),\r\n                        last_li,\r\n                        loose = false,\r\n                        ret = [stack[0].list],\r\n                        i;\r\n\r\n                    // Loop to search over block looking for inner block elements and loose lists\r\n                    loose_search:\r\n                    while (true) {\r\n                        // Split into lines preserving new lines at end of line\r\n                        var lines = block.split(/(?=\\n)/);\r\n\r\n                        // We have to grab all lines for a li and call processInline on them\r\n                        // once as there are some inline things that can span lines.\r\n                        var li_accumulate = \"\";\r\n\r\n                        // Loop over the lines in this block looking for tight lists.\r\n                        tight_search:\r\n                        for (var line_no = 0; line_no < lines.length; line_no++) {\r\n                            var nl = \"\",\r\n                                l = lines[line_no].replace(/^\\n/, function (n) { nl = n; return \"\"; });\r\n\r\n                            // TODO: really should cache this\r\n                            var line_re = regex_for_depth(stack.length);\r\n\r\n                            m = l.match(line_re);\r\n                            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\r\n\r\n                            // We have a list item\r\n                            if (m[1] !== undefined) {\r\n                                // Process the previous list item, if any\r\n                                if (li_accumulate.length) {\r\n                                    add(last_li, loose, this.processInline(li_accumulate), nl);\r\n                                    // Loose mode will have been dealt with. Reset it\r\n                                    loose = false;\r\n                                    li_accumulate = \"\";\r\n                                }\r\n\r\n                                m[1] = expand_tab(m[1]);\r\n                                var wanted_depth = Math.floor(m[1].length / 4) + 1;\r\n                                //print( \"want:\", wanted_depth, \"stack:\", stack.length);\r\n                                if (wanted_depth > stack.length) {\r\n                                    // Deep enough for a nested list outright\r\n                                    //print ( \"new nested list\" );\r\n                                    list = make_list(m);\r\n                                    last_li.push(list);\r\n                                    last_li = list[1] = [\"listitem\"];\r\n                                }\r\n                                else {\r\n                                    // We aren't deep enough to be strictly a new level. This is\r\n                                    // where Md.pl goes nuts. If the indent matches a level in the\r\n                                    // stack, put it there, else put it one deeper then the\r\n                                    // wanted_depth deserves.\r\n                                    var found = false;\r\n                                    for (i = 0; i < stack.length; i++) {\r\n                                        if (stack[i].indent != m[1]) continue;\r\n                                        list = stack[i].list;\r\n                                        stack.splice(i + 1);\r\n                                        found = true;\r\n                                        break;\r\n                                    }\r\n\r\n                                    if (!found) {\r\n                                        //print(\"not found. l:\", uneval(l));\r\n                                        wanted_depth++;\r\n                                        if (wanted_depth <= stack.length) {\r\n                                            stack.splice(wanted_depth);\r\n                                            //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\r\n                                            list = stack[wanted_depth - 1].list;\r\n                                            //print(\"list:\", uneval(list) );\r\n                                        }\r\n                                        else {\r\n                                            //print (\"made new stack for messy indent\");\r\n                                            list = make_list(m);\r\n                                            last_li.push(list);\r\n                                        }\r\n                                    }\r\n\r\n                                    //print( uneval(list), \"last\", list === stack[stack.length-1].list );\r\n                                    last_li = [\"listitem\"];\r\n                                    list.push(last_li);\r\n                                } // end depth of shenegains\r\n                                nl = \"\";\r\n                            }\r\n\r\n                            // Add content\r\n                            if (l.length > m[0].length) {\r\n                                li_accumulate += nl + l.substr(m[0].length);\r\n                            }\r\n                        } // tight_search\r\n\r\n                        if (li_accumulate.length) {\r\n                            add(last_li, loose, this.processInline(li_accumulate), nl);\r\n                            // Loose mode will have been dealt with. Reset it\r\n                            loose = false;\r\n                            li_accumulate = \"\";\r\n                        }\r\n\r\n                        // Look at the next block - we might have a loose list. Or an extra\r\n                        // paragraph for the current li\r\n                        var contained = get_contained_blocks(stack.length, next);\r\n\r\n                        // Deal with code blocks or properly nested lists\r\n                        if (contained.length > 0) {\r\n                            // Make sure all listitems up the stack are paragraphs\r\n                            forEach(stack, paragraphify, this);\r\n\r\n                            last_li.push.apply(last_li, this.toTree(contained, []));\r\n                        }\r\n\r\n                        var next_block = next[0] && next[0].valueOf() || \"\";\r\n\r\n                        if (next_block.match(is_list_re) || next_block.match(/^ /)) {\r\n                            block = next.shift();\r\n\r\n                            // Check for an HR following a list: features/lists/hr_abutting\r\n                            var hr = this.dialect.block.horizRule(block, next);\r\n\r\n                            if (hr) {\r\n                                ret.push.apply(ret, hr);\r\n                                break;\r\n                            }\r\n\r\n                            // Make sure all listitems up the stack are paragraphs\r\n                            forEach(stack, paragraphify, this);\r\n\r\n                            loose = true;\r\n                            continue loose_search;\r\n                        }\r\n                        break;\r\n                    } // loose_search\r\n\r\n                    return ret;\r\n                };\r\n            })(),\r\n\r\n            blockquote: function blockquote(block, next) {\r\n                if (!block.match(/^>/m))\r\n                    return undefined;\r\n\r\n                var jsonml = [];\r\n\r\n                // separate out the leading abutting block, if any\r\n                if (block[0] != \">\") {\r\n                    var lines = block.split(/\\n/),\r\n                        prev = [];\r\n\r\n                    // keep shifting lines until you find a crotchet\r\n                    while (lines.length && lines[0][0] != \">\") {\r\n                        prev.push(lines.shift());\r\n                    }\r\n\r\n                    // reassemble!\r\n                    block = lines.join(\"\\n\");\r\n                    jsonml.push.apply(jsonml, this.processBlock(prev.join(\"\\n\"), []));\r\n                }\r\n\r\n                // if the next block is also a blockquote merge it in\r\n                while (next.length && next[0][0] == \">\") {\r\n                    var b = next.shift();\r\n                    block = new String(block + block.trailing + b);\r\n                    block.trailing = b.trailing;\r\n                }\r\n\r\n                // Strip off the leading \"> \" and re-process as a block.\r\n                var input = block.replace(/^> ?/gm, ''),\r\n                    old_tree = this.tree;\r\n                jsonml.push(this.toTree(input, [\"blockquote\"]));\r\n\r\n                return jsonml;\r\n            },\r\n\r\n            referenceDefn: function referenceDefn(block, next) {\r\n                var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\r\n                // interesting matches are [ , ref_id, url, , title, title ]\r\n\r\n                if (!block.match(re))\r\n                    return undefined;\r\n\r\n                // make an attribute node if it doesn't exist\r\n                if (!extract_attr(this.tree)) {\r\n                    this.tree.splice(1, 0, {});\r\n                }\r\n\r\n                var attrs = extract_attr(this.tree);\r\n\r\n                // make a references hash if it doesn't exist\r\n                if (attrs.references === undefined) {\r\n                    attrs.references = {};\r\n                }\r\n\r\n                var b = this.loop_re_over_block(re, block, function (m) {\r\n\r\n                    if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')\r\n                        m[2] = m[2].substring(1, m[2].length - 1);\r\n\r\n                    var ref = attrs.references[m[1].toLowerCase()] = {\r\n                        href: m[2]\r\n                    };\r\n\r\n                    if (m[4] !== undefined)\r\n                        ref.title = m[4];\r\n                    else if (m[5] !== undefined)\r\n                        ref.title = m[5];\r\n\r\n                });\r\n\r\n                if (b.length)\r\n                    next.unshift(mk_block(b, block.trailing));\r\n\r\n                return [];\r\n            },\r\n\r\n            para: function para(block, next) {\r\n                // everything's a para!\r\n                return [[\"para\"].concat(this.processInline(block))];\r\n            }\r\n        }\r\n    };\r\n\r\n    Markdown.dialects.Gruber.inline = {\r\n\r\n        __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {\r\n            var m,\r\n                res,\r\n                lastIndex = 0;\r\n\r\n            patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\r\n            var re = new RegExp(\"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\");\r\n\r\n            m = re.exec(text);\r\n            if (!m) {\r\n                // Just boring text\r\n                return [text.length, text];\r\n            }\r\n            else if (m[1]) {\r\n                // Some un-interesting text matched. Return that first\r\n                return [m[1].length, m[1]];\r\n            }\r\n\r\n            var res;\r\n            if (m[2] in this.dialect.inline) {\r\n                res = this.dialect.inline[m[2]].call(\r\n                    this,\r\n                    text.substr(m.index), m, previous_nodes || []);\r\n            }\r\n            // Default for now to make dev easier. just slurp special and output it.\r\n            res = res || [m[2].length, m[2]];\r\n            return res;\r\n        },\r\n\r\n        __call__: function inline(text, patterns) {\r\n\r\n            var out = [],\r\n                res;\r\n\r\n            function add(x) {\r\n                //D:self.debug(\"  adding output\", uneval(x));\r\n                if (typeof x == \"string\" && typeof out[out.length - 1] == \"string\")\r\n                    out[out.length - 1] += x;\r\n                else\r\n                    out.push(x);\r\n            }\r\n\r\n            while (text.length > 0) {\r\n                res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);\r\n                text = text.substr(res.shift());\r\n                forEach(res, add)\r\n            }\r\n\r\n            return out;\r\n        },\r\n\r\n        // These characters are intersting elsewhere, so have rules for them so that\r\n        // chunks of plain text blocks don't include them\r\n        \"]\": function () { },\r\n        \"}\": function () { },\r\n\r\n        \"\\\\\": function escaped(text) {\r\n            // [ length of input processed, node/children to add... ]\r\n            // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\r\n            if (text.match(/^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/))\r\n                return [2, text[1]];\r\n            else\r\n                // Not an esacpe\r\n                return [1, \"\\\\\"];\r\n        },\r\n\r\n        \"![\": function image(text) {\r\n\r\n            // Unlike images, alt text is plain text only. no other elements are\r\n            // allowed in there\r\n\r\n            // ![Alt text](/path/to/img.jpg \"Optional title\")\r\n            //      1          2            3       4         <--- captures\r\n            var m = text.match(/^!\\[(.*?)\\][ \\t]*\\([ \\t]*(\\S*)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/);\r\n\r\n            if (m) {\r\n                if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')\r\n                    m[2] = m[2].substring(1, m[2].length - 1);\r\n\r\n                m[2] = this.dialect.inline.__call__.call(this, m[2], /\\\\/)[0];\r\n\r\n                var attrs = { alt: m[1], href: m[2] || \"\" };\r\n                if (m[4] !== undefined)\r\n                    attrs.title = m[4];\r\n\r\n                return [m[0].length, [\"img\", attrs]];\r\n            }\r\n\r\n            // ![Alt text][id]\r\n            m = text.match(/^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/);\r\n\r\n            if (m) {\r\n                // We can't check if the reference is known here as it likely wont be\r\n                // found till after. Check it in md tree->hmtl tree conversion\r\n                return [m[0].length, [\"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] }]];\r\n            }\r\n\r\n            // Just consume the '!['\r\n            return [2, \"![\"];\r\n        },\r\n\r\n        \"[\": function link(text) {\r\n\r\n            var orig = String(text);\r\n            // Inline content is possible inside `link text`\r\n            var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), ']');\r\n\r\n            // No closing ']' found. Just consume the [\r\n            if (!res) return [1, '['];\r\n\r\n            var consumed = 1 + res[0],\r\n                children = res[1],\r\n                link,\r\n                attrs;\r\n\r\n            // At this point the first [...] has been parsed. See what follows to find\r\n            // out which kind of link we are (reference or direct url)\r\n            text = text.substr(consumed);\r\n\r\n            // [link text](/path/to/img.jpg \"Optional title\")\r\n            //                 1            2       3         <--- captures\r\n            // This will capture up to the last paren in the block. We then pull\r\n            // back based on if there a matching ones in the url\r\n            //    ([here](/url/(test))\r\n            // The parens have to be balanced\r\n            var m = text.match(/^\\s*\\([ \\t]*(\\S+)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/);\r\n            if (m) {\r\n                var url = m[1];\r\n                consumed += m[0].length;\r\n\r\n                if (url && url[0] == '<' && url[url.length - 1] == '>')\r\n                    url = url.substring(1, url.length - 1);\r\n\r\n                // If there is a title we don't have to worry about parens in the url\r\n                if (!m[3]) {\r\n                    var open_parens = 1; // One open that isn't in the capture\r\n                    for (var len = 0; len < url.length; len++) {\r\n                        switch (url[len]) {\r\n                            case '(':\r\n                                open_parens++;\r\n                                break;\r\n                            case ')':\r\n                                if (--open_parens == 0) {\r\n                                    consumed -= url.length - len;\r\n                                    url = url.substring(0, len);\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Process escapes only\r\n                url = this.dialect.inline.__call__.call(this, url, /\\\\/)[0];\r\n\r\n                attrs = { href: url || \"\" };\r\n                if (m[3] !== undefined)\r\n                    attrs.title = m[3];\r\n\r\n                link = [\"link\", attrs].concat(children);\r\n                return [consumed, link];\r\n            }\r\n\r\n            // [Alt text][id]\r\n            // [Alt text] [id]\r\n            m = text.match(/^\\s*\\[(.*?)\\]/);\r\n\r\n            if (m) {\r\n\r\n                consumed += m[0].length;\r\n\r\n                // [links][] uses links as its reference\r\n                attrs = { ref: (m[1] || String(children)).toLowerCase(), original: orig.substr(0, consumed) };\r\n\r\n                link = [\"link_ref\", attrs].concat(children);\r\n\r\n                // We can't check if the reference is known here as it likely wont be\r\n                // found till after. Check it in md tree->hmtl tree conversion.\r\n                // Store the original so that conversion can revert if the ref isn't found.\r\n                return [consumed, link];\r\n            }\r\n\r\n            // [id]\r\n            // Only if id is plain (no formatting.)\r\n            if (children.length == 1 && typeof children[0] == \"string\") {\r\n\r\n                attrs = { ref: children[0].toLowerCase(), original: orig.substr(0, consumed) };\r\n                link = [\"link_ref\", attrs, children[0]];\r\n                return [consumed, link];\r\n            }\r\n\r\n            // Just consume the '['\r\n            return [1, \"[\"];\r\n        },\r\n\r\n\r\n        \"<\": function autoLink(text) {\r\n            var m;\r\n\r\n            if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/)) != null) {\r\n                if (m[3]) {\r\n                    return [m[0].length, [\"link\", { href: \"mailto:\" + m[3] }, m[3]]];\r\n\r\n                }\r\n                else if (m[2] == \"mailto\") {\r\n                    return [m[0].length, [\"link\", { href: m[1] }, m[1].substr(\"mailto:\".length)]];\r\n                }\r\n                else\r\n                    return [m[0].length, [\"link\", { href: m[1] }, m[1]]];\r\n            }\r\n\r\n            return [1, \"<\"];\r\n        },\r\n\r\n        \"`\": function inlineCode(text) {\r\n            // Inline code block. as many backticks as you like to start it\r\n            // Always skip over the opening ticks.\r\n            var m = text.match(/(`+)(([\\s\\S]*?)\\1)/);\r\n\r\n            if (m && m[2])\r\n                return [m[1].length + m[2].length, [\"inlinecode\", m[3]]];\r\n            else {\r\n                // TODO: No matching end code found - warn!\r\n                return [1, \"`\"];\r\n            }\r\n        },\r\n\r\n        \"  \\n\": function lineBreak(text) {\r\n            return [3, [\"linebreak\"]];\r\n        }\r\n\r\n    };\r\n\r\n    // Meta Helper/generator method for em and strong handling\r\n    function strong_em(tag, md) {\r\n\r\n        var state_slot = tag + \"_state\",\r\n            other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\r\n\r\n        function CloseTag(len) {\r\n            this.len_after = len;\r\n            this.name = \"close_\" + md;\r\n        }\r\n\r\n        return function (text, orig_match) {\r\n\r\n            if (this[state_slot][0] == md) {\r\n                // Most recent em is of this type\r\n                //D:this.debug(\"closing\", md);\r\n                this[state_slot].shift();\r\n\r\n                // \"Consume\" everything to go back to the recrusion in the else-block below\r\n                return [text.length, new CloseTag(text.length - md.length)];\r\n            }\r\n            else {\r\n                // Store a clone of the em/strong states\r\n                var other = this[other_slot].slice(),\r\n                    state = this[state_slot].slice();\r\n\r\n                this[state_slot].unshift(md);\r\n\r\n                //D:this.debug_indent += \"  \";\r\n\r\n                // Recurse\r\n                var res = this.processInline(text.substr(md.length));\r\n                //D:this.debug_indent = this.debug_indent.substr(2);\r\n\r\n                var last = res[res.length - 1];\r\n\r\n                //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\r\n\r\n                var check = this[state_slot].shift();\r\n                if (last instanceof CloseTag) {\r\n                    res.pop();\r\n                    // We matched! Huzzah.\r\n                    var consumed = text.length - last.len_after;\r\n                    return [consumed, [tag].concat(res)];\r\n                }\r\n                else {\r\n                    // Restore the state of the other kind. We might have mistakenly closed it.\r\n                    this[other_slot] = other;\r\n                    this[state_slot] = state;\r\n\r\n                    // We can't reuse the processed r as it could have wrong parsing contexts in it.\r\n                    return [md.length, md];\r\n                }\r\n            }\r\n        }; // End returned function\r\n    }\r\n\r\n    Markdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\r\n    Markdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\r\n    Markdown.dialects.Gruber.inline[\"*\"] = strong_em(\"em\", \"*\");\r\n    Markdown.dialects.Gruber.inline[\"_\"] = strong_em(\"em\", \"_\");\r\n\r\n\r\n    // Build default order from insertion order.\r\n    Markdown.buildBlockOrder = function (d) {\r\n        var ord = [];\r\n        for (var i in d) {\r\n            if (i == \"__order__\" || i == \"__call__\") continue;\r\n            ord.push(i);\r\n        }\r\n        d.__order__ = ord;\r\n    };\r\n\r\n    // Build patterns for inline matcher\r\n    Markdown.buildInlinePatterns = function (d) {\r\n        var patterns = [];\r\n\r\n        for (var i in d) {\r\n            // __foo__ is reserved and not a pattern\r\n            if (i.match(/^__.*__$/)) continue;\r\n            var l = i.replace(/([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\")\r\n                .replace(/\\n/, \"\\\\n\");\r\n            patterns.push(i.length == 1 ? l : \"(?:\" + l + \")\");\r\n        }\r\n\r\n        patterns = patterns.join(\"|\");\r\n        d.__patterns__ = patterns;\r\n        //print(\"patterns:\", uneval( patterns ) );\r\n\r\n        var fn = d.__call__;\r\n        d.__call__ = function (text, pattern) {\r\n            if (pattern != undefined) {\r\n                return fn.call(this, text, pattern);\r\n            }\r\n            else {\r\n                return fn.call(this, text, patterns);\r\n            }\r\n        };\r\n    };\r\n\r\n    Markdown.DialectHelpers = {};\r\n    Markdown.DialectHelpers.inline_until_char = function (text, want) {\r\n        var consumed = 0,\r\n            nodes = [];\r\n\r\n        while (true) {\r\n            if (text[consumed] == want) {\r\n                // Found the character we were looking for\r\n                consumed++;\r\n                return [consumed, nodes];\r\n            }\r\n\r\n            if (consumed >= text.length) {\r\n                // No closing char found. Abort.\r\n                return null;\r\n            }\r\n\r\n            var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));\r\n            consumed += res[0];\r\n            // Add any returned nodes.\r\n            nodes.push.apply(nodes, res.slice(1));\r\n        }\r\n    }\r\n\r\n    // Helper function to make sub-classing a dialect easier\r\n    Markdown.subclassDialect = function (d) {\r\n        function Block() { }\r\n        Block.prototype = d.block;\r\n        function Inline() { }\r\n        Inline.prototype = d.inline;\r\n\r\n        return { block: new Block(), inline: new Inline() };\r\n    };\r\n\r\n    Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);\r\n    Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);\r\n\r\n    Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);\r\n\r\n    Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {\r\n        var meta = split_meta_hash(meta_string),\r\n            attr = {};\r\n\r\n        for (var i = 0; i < meta.length; ++i) {\r\n            // id: #foo\r\n            if (/^#/.test(meta[i])) {\r\n                attr.id = meta[i].substring(1);\r\n            }\r\n            // class: .foo\r\n            else if (/^\\./.test(meta[i])) {\r\n                // if class already exists, append the new one\r\n                if (attr['class']) {\r\n                    attr['class'] = attr['class'] + meta[i].replace(/./, \" \");\r\n                }\r\n                else {\r\n                    attr['class'] = meta[i].substring(1);\r\n                }\r\n            }\r\n            // attribute: foo=bar\r\n            else if (/\\=/.test(meta[i])) {\r\n                var s = meta[i].split(/\\=/);\r\n                attr[s[0]] = s[1];\r\n            }\r\n        }\r\n\r\n        return attr;\r\n    }\r\n\r\n    function split_meta_hash(meta_string) {\r\n        var meta = meta_string.split(\"\"),\r\n            parts = [\"\"],\r\n            in_quotes = false;\r\n\r\n        while (meta.length) {\r\n            var letter = meta.shift();\r\n            switch (letter) {\r\n                case \" \":\r\n                    // if we're in a quoted section, keep it\r\n                    if (in_quotes) {\r\n                        parts[parts.length - 1] += letter;\r\n                    }\r\n                    // otherwise make a new part\r\n                    else {\r\n                        parts.push(\"\");\r\n                    }\r\n                    break;\r\n                case \"'\":\r\n                case '\"':\r\n                    // reverse the quotes and move straight on\r\n                    in_quotes = !in_quotes;\r\n                    break;\r\n                case \"\\\\\":\r\n                    // shift off the next letter to be used straight away.\r\n                    // it was escaped so we'll keep it whatever it is\r\n                    letter = meta.shift();\r\n                default:\r\n                    parts[parts.length - 1] += letter;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return parts;\r\n    }\r\n\r\n    Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {\r\n        // we're only interested in the first block\r\n        if (block.lineNumber > 1) return undefined;\r\n\r\n        // document_meta blocks consist of one or more lines of `Key: Value\\n`\r\n        if (!block.match(/^(?:\\w+:.*\\n)*\\w+:.*$/)) return undefined;\r\n\r\n        // make an attribute node if it doesn't exist\r\n        if (!extract_attr(this.tree)) {\r\n            this.tree.splice(1, 0, {});\r\n        }\r\n\r\n        var pairs = block.split(/\\n/);\r\n        for (p in pairs) {\r\n            var m = pairs[p].match(/(\\w+):\\s*(.*)$/),\r\n                key = m[1].toLowerCase(),\r\n                value = m[2];\r\n\r\n            this.tree[1][key] = value;\r\n        }\r\n\r\n        // document_meta produces no content!\r\n        return [];\r\n    };\r\n\r\n    Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {\r\n        // check if the last line of the block is an meta hash\r\n        var m = block.match(/(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/);\r\n        if (!m) return undefined;\r\n\r\n        // process the meta hash\r\n        var attr = this.dialect.processMetaHash(m[2]);\r\n\r\n        var hash;\r\n\r\n        // if we matched ^ then we need to apply meta to the previous block\r\n        if (m[1] === \"\") {\r\n            var node = this.tree[this.tree.length - 1];\r\n            hash = extract_attr(node);\r\n\r\n            // if the node is a string (rather than JsonML), bail\r\n            if (typeof node === \"string\") return undefined;\r\n\r\n            // create the attribute hash if it doesn't exist\r\n            if (!hash) {\r\n                hash = {};\r\n                node.splice(1, 0, hash);\r\n            }\r\n\r\n            // add the attributes in\r\n            for (a in attr) {\r\n                hash[a] = attr[a];\r\n            }\r\n\r\n            // return nothing so the meta hash is removed\r\n            return [];\r\n        }\r\n\r\n        // pull the meta hash off the block and process what's left\r\n        var b = block.replace(/\\n.*$/, \"\"),\r\n            r = this.processBlock(b, []);\r\n\r\n        // get or make the attributes hash\r\n        hash = extract_attr(r[0]);\r\n        if (!hash) {\r\n            hash = {};\r\n            r[0].splice(1, 0, hash);\r\n        }\r\n\r\n        // attach the attributes to the block\r\n        for (a in attr) {\r\n            hash[a] = attr[a];\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {\r\n        // one or more terms followed by one or more definitions, in a single block\r\n        var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\r\n            list = [\"dl\"],\r\n            i;\r\n\r\n        // see if we're dealing with a tight or loose block\r\n        if ((m = block.match(tight))) {\r\n            // pull subsequent tight DL blocks out of `next`\r\n            var blocks = [block];\r\n            while (next.length && tight.exec(next[0])) {\r\n                blocks.push(next.shift());\r\n            }\r\n\r\n            for (var b = 0; b < blocks.length; ++b) {\r\n                var m = blocks[b].match(tight),\r\n                    terms = m[1].replace(/\\n$/, \"\").split(/\\n/),\r\n                    defns = m[2].split(/\\n:\\s+/);\r\n\r\n                // print( uneval( m ) );\r\n\r\n                for (i = 0; i < terms.length; ++i) {\r\n                    list.push([\"dt\", terms[i]]);\r\n                }\r\n\r\n                for (i = 0; i < defns.length; ++i) {\r\n                    // run inline processing over the definition\r\n                    list.push([\"dd\"].concat(this.processInline(defns[i].replace(/(\\n)\\s+/, \"$1\"))));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n\r\n        return [list];\r\n    };\r\n\r\n    Markdown.dialects.Maruku.inline[\"{:\"] = function inline_meta(text, matches, out) {\r\n        if (!out.length) {\r\n            return [2, \"{:\"];\r\n        }\r\n\r\n        // get the preceeding element\r\n        var before = out[out.length - 1];\r\n\r\n        if (typeof before === \"string\") {\r\n            return [2, \"{:\"];\r\n        }\r\n\r\n        // match a meta hash\r\n        var m = text.match(/^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/);\r\n\r\n        // no match, false alarm\r\n        if (!m) {\r\n            return [2, \"{:\"];\r\n        }\r\n\r\n        // attach the attributes to the preceeding element\r\n        var meta = this.dialect.processMetaHash(m[1]),\r\n            attr = extract_attr(before);\r\n\r\n        if (!attr) {\r\n            attr = {};\r\n            before.splice(1, 0, attr);\r\n        }\r\n\r\n        for (var k in meta) {\r\n            attr[k] = meta[k];\r\n        }\r\n\r\n        // cut out the string and replace it with nothing\r\n        return [m[0].length, \"\"];\r\n    };\r\n\r\n    Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);\r\n    Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);\r\n\r\n    var isArray = Array.isArray || function (obj) {\r\n        return Object.prototype.toString.call(obj) == '[object Array]';\r\n    };\r\n\r\n    var forEach;\r\n    // Don't mess with Array.prototype. Its not friendly\r\n    if (Array.prototype.forEach) {\r\n        forEach = function (arr, cb, thisp) {\r\n            return arr.forEach(cb, thisp);\r\n        };\r\n    }\r\n    else {\r\n        forEach = function (arr, cb, thisp) {\r\n            for (var i = 0; i < arr.length; i++) {\r\n                cb.call(thisp || arr, arr[i], i, arr);\r\n            }\r\n        }\r\n    }\r\n\r\n    function extract_attr(jsonml) {\r\n        return isArray(jsonml)\r\n            && jsonml.length > 1\r\n            && typeof jsonml[1] === \"object\"\r\n            && !(isArray(jsonml[1]))\r\n            ? jsonml[1]\r\n            : undefined;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     *  renderJsonML( jsonml[, options] ) -> String\r\n     *  - jsonml (Array): JsonML array to render to XML\r\n     *  - options (Object): options\r\n     *\r\n     *  Converts the given JsonML into well-formed XML.\r\n     *\r\n     *  The options currently understood are:\r\n     *\r\n     *  - root (Boolean): wether or not the root node should be included in the\r\n     *    output, or just its children. The default `false` is to not include the\r\n     *    root itself.\r\n     */\r\n    expose.renderJsonML = function (jsonml, options) {\r\n        options = options || {};\r\n        // include the root element in the rendered output?\r\n        options.root = options.root || false;\r\n\r\n        var content = [];\r\n\r\n        if (options.root) {\r\n            content.push(render_tree(jsonml));\r\n        }\r\n        else {\r\n            jsonml.shift(); // get rid of the tag\r\n            if (jsonml.length && typeof jsonml[0] === \"object\" && !(jsonml[0] instanceof Array)) {\r\n                jsonml.shift(); // get rid of the attributes\r\n            }\r\n\r\n            while (jsonml.length) {\r\n                content.push(render_tree(jsonml.shift()));\r\n            }\r\n        }\r\n\r\n        return content.join(\"\\n\\n\");\r\n    };\r\n\r\n    function escapeHTML(text) {\r\n        return text.replace(/&/g, \"&amp;\")\r\n            .replace(/</g, \"&lt;\")\r\n            .replace(/>/g, \"&gt;\")\r\n            .replace(/\"/g, \"&quot;\")\r\n            .replace(/'/g, \"&#39;\");\r\n    }\r\n\r\n    function render_tree(jsonml) {\r\n        // basic case\r\n        if (typeof jsonml === \"string\") {\r\n            return escapeHTML(jsonml);\r\n        }\r\n\r\n        var tag = jsonml.shift(),\r\n            attributes = {},\r\n            content = [];\r\n\r\n        if (jsonml.length && typeof jsonml[0] === \"object\" && !(jsonml[0] instanceof Array)) {\r\n            attributes = jsonml.shift();\r\n        }\r\n\r\n        while (jsonml.length) {\r\n            content.push(arguments.callee(jsonml.shift()));\r\n        }\r\n\r\n        var tag_attrs = \"\";\r\n        for (var a in attributes) {\r\n            tag_attrs += \" \" + a + '=\"' + escapeHTML(attributes[a]) + '\"';\r\n        }\r\n\r\n        // be careful about adding whitespace here for inline elements\r\n        if (tag == \"img\" || tag == \"br\" || tag == \"hr\") {\r\n            return \"<\" + tag + tag_attrs + \"/>\";\r\n        }\r\n        else {\r\n            return \"<\" + tag + tag_attrs + \">\" + content.join(\"\") + \"</\" + tag + \">\";\r\n        }\r\n    }\r\n\r\n    function convert_tree_to_html(tree, references, options) {\r\n        var i;\r\n        options = options || {};\r\n\r\n        // shallow clone\r\n        var jsonml = tree.slice(0);\r\n\r\n        if (typeof options.preprocessTreeNode === \"function\") {\r\n            jsonml = options.preprocessTreeNode(jsonml, references);\r\n        }\r\n\r\n        // Clone attributes if they exist\r\n        var attrs = extract_attr(jsonml);\r\n        if (attrs) {\r\n            jsonml[1] = {};\r\n            for (i in attrs) {\r\n                jsonml[1][i] = attrs[i];\r\n            }\r\n            attrs = jsonml[1];\r\n        }\r\n\r\n        // basic case\r\n        if (typeof jsonml === \"string\") {\r\n            return jsonml;\r\n        }\r\n\r\n        // convert this node\r\n        switch (jsonml[0]) {\r\n            case \"header\":\r\n                jsonml[0] = \"h\" + jsonml[1].level;\r\n                delete jsonml[1].level;\r\n                break;\r\n            case \"bulletlist\":\r\n                jsonml[0] = \"ul\";\r\n                break;\r\n            case \"numberlist\":\r\n                jsonml[0] = \"ol\";\r\n                break;\r\n            case \"listitem\":\r\n                jsonml[0] = \"li\";\r\n                break;\r\n            case \"para\":\r\n                jsonml[0] = \"p\";\r\n                break;\r\n            case \"markdown\":\r\n                jsonml[0] = \"html\";\r\n                if (attrs) delete attrs.references;\r\n                break;\r\n            case \"code_block\":\r\n                jsonml[0] = \"pre\";\r\n                i = attrs ? 2 : 1;\r\n                var code = [\"code\"];\r\n                code.push.apply(code, jsonml.splice(i));\r\n                jsonml[i] = code;\r\n                break;\r\n            case \"inlinecode\":\r\n                jsonml[0] = \"code\";\r\n                break;\r\n            case \"img\":\r\n                jsonml[1].src = jsonml[1].href;\r\n                delete jsonml[1].href;\r\n                break;\r\n            case \"linebreak\":\r\n                jsonml[0] = \"br\";\r\n                break;\r\n            case \"link\":\r\n                jsonml[0] = \"a\";\r\n                break;\r\n            case \"link_ref\":\r\n                jsonml[0] = \"a\";\r\n\r\n                // grab this ref and clean up the attribute node\r\n                var ref = references[attrs.ref];\r\n\r\n                // if the reference exists, make the link\r\n                if (ref) {\r\n                    delete attrs.ref;\r\n\r\n                    // add in the href and title, if present\r\n                    attrs.href = ref.href;\r\n                    if (ref.title) {\r\n                        attrs.title = ref.title;\r\n                    }\r\n\r\n                    // get rid of the unneeded original text\r\n                    delete attrs.original;\r\n                }\r\n                // the reference doesn't exist, so revert to plain text\r\n                else {\r\n                    return attrs.original;\r\n                }\r\n                break;\r\n            case \"img_ref\":\r\n                jsonml[0] = \"img\";\r\n\r\n                // grab this ref and clean up the attribute node\r\n                var ref = references[attrs.ref];\r\n\r\n                // if the reference exists, make the link\r\n                if (ref) {\r\n                    delete attrs.ref;\r\n\r\n                    // add in the href and title, if present\r\n                    attrs.src = ref.href;\r\n                    if (ref.title) {\r\n                        attrs.title = ref.title;\r\n                    }\r\n\r\n                    // get rid of the unneeded original text\r\n                    delete attrs.original;\r\n                }\r\n                // the reference doesn't exist, so revert to plain text\r\n                else {\r\n                    return attrs.original;\r\n                }\r\n                break;\r\n        }\r\n\r\n        // convert all the children\r\n        i = 1;\r\n\r\n        // deal with the attribute node, if it exists\r\n        if (attrs) {\r\n            // if there are keys, skip over it\r\n            for (var key in jsonml[1]) {\r\n                i = 2;\r\n            }\r\n            // if there aren't, remove it\r\n            if (i === 1) {\r\n                jsonml.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        for (; i < jsonml.length; ++i) {\r\n            jsonml[i] = arguments.callee(jsonml[i], references, options);\r\n        }\r\n\r\n        return jsonml;\r\n    }\r\n\r\n\r\n    // merges adjacent text nodes into a single node\r\n    function merge_text_nodes(jsonml) {\r\n        // skip the tag name and attribute hash\r\n        var i = extract_attr(jsonml) ? 2 : 1;\r\n\r\n        while (i < jsonml.length) {\r\n            // if it's a string check the next item too\r\n            if (typeof jsonml[i] === \"string\") {\r\n                if (i + 1 < jsonml.length && typeof jsonml[i + 1] === \"string\") {\r\n                    // merge the second string into the first and remove it\r\n                    jsonml[i] += jsonml.splice(i + 1, 1)[0];\r\n                }\r\n                else {\r\n                    ++i;\r\n                }\r\n            }\r\n            // if it's not a string recurse\r\n            else {\r\n                arguments.callee(jsonml[i]);\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n})(typeof exports === \"object\" ? exports : (Markdown = {}));\r\n"],"mappings":"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"}